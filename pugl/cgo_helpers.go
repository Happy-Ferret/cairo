// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sat, 06 Jan 2018 19:12:26 EST.
// By https://git.io/c-for-go. DO NOT EDIT.

package pugl

/*
#cgo pkg-config: cairo
#include "pugl.h"
#include "cairo_gl.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"sync"
	"unsafe"
)

// Ref returns a reference to C object as it is.
func (x *View) Ref() *C.PuglView {
	if x == nil {
		return nil
	}
	return (*C.PuglView)(unsafe.Pointer(x))
}

// Free cleanups the referenced memory using C free.
func (x *View) Free() {
	if x != nil {
		C.free(unsafe.Pointer(x))
	}
}

// NewViewRef converts the C object reference into a raw struct reference without wrapping.
func NewViewRef(ref unsafe.Pointer) *View {
	return (*View)(ref)
}

// NewView allocates a new C object of this type and converts the reference into
// a raw struct reference without wrapping.
func NewView() *View {
	return (*View)(allocViewMemory(1))
}

// allocViewMemory allocates memory for type C.PuglView in C.
// The caller is responsible for freeing the this memory via C.free.
func allocViewMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfViewValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfViewValue = unsafe.Sizeof([1]C.PuglView{})

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// PassRef returns a reference to C object as it is or allocates a new C object of this type.
func (x *View) PassRef() *C.PuglView {
	if x == nil {
		x = (*View)(allocViewMemory(1))
	}
	return (*C.PuglView)(unsafe.Pointer(x))
}

// allocEventAnyMemory allocates memory for type C.PuglEventAny in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventAnyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventAnyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventAnyValue = unsafe.Sizeof([1]C.PuglEventAny{})

type sliceHeader struct {
	Data uintptr
	Len  int
	Cap  int
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventAny) Ref() *C.PuglEventAny {
	if x == nil {
		return nil
	}
	return x.ref96eb2ebb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventAny) Free() {
	if x != nil && x.allocs96eb2ebb != nil {
		x.allocs96eb2ebb.(*cgoAllocMap).Free()
		x.ref96eb2ebb = nil
	}
}

// NewEventAnyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventAnyRef(ref unsafe.Pointer) *EventAny {
	if ref == nil {
		return nil
	}
	obj := new(EventAny)
	obj.ref96eb2ebb = (*C.PuglEventAny)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventAny) PassRef() (*C.PuglEventAny, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref96eb2ebb != nil {
		return x.ref96eb2ebb, nil
	}
	mem96eb2ebb := allocEventAnyMemory(1)
	ref96eb2ebb := (*C.PuglEventAny)(mem96eb2ebb)
	allocs96eb2ebb := new(cgoAllocMap)
	allocs96eb2ebb.Add(mem96eb2ebb)

	var c_type_allocs *cgoAllocMap
	ref96eb2ebb._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs96eb2ebb.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref96eb2ebb.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs96eb2ebb.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref96eb2ebb.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs96eb2ebb.Borrow(cflags_allocs)

	x.ref96eb2ebb = ref96eb2ebb
	x.allocs96eb2ebb = allocs96eb2ebb
	return ref96eb2ebb, allocs96eb2ebb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventAny) PassValue() (C.PuglEventAny, *cgoAllocMap) {
	if x.ref96eb2ebb != nil {
		return *x.ref96eb2ebb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventAny) Deref() {
	if x.ref96eb2ebb == nil {
		return
	}
	x.Type = (EventType)(x.ref96eb2ebb._type)
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxfc4425b.Data = uintptr(unsafe.Pointer(x.ref96eb2ebb.view))
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.Flags = (uint32)(x.ref96eb2ebb.flags)
}

// allocEventButtonMemory allocates memory for type C.PuglEventButton in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventButtonMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventButtonValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventButtonValue = unsafe.Sizeof([1]C.PuglEventButton{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventButton) Ref() *C.PuglEventButton {
	if x == nil {
		return nil
	}
	return x.ref72cc0df2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventButton) Free() {
	if x != nil && x.allocs72cc0df2 != nil {
		x.allocs72cc0df2.(*cgoAllocMap).Free()
		x.ref72cc0df2 = nil
	}
}

// NewEventButtonRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventButtonRef(ref unsafe.Pointer) *EventButton {
	if ref == nil {
		return nil
	}
	obj := new(EventButton)
	obj.ref72cc0df2 = (*C.PuglEventButton)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventButton) PassRef() (*C.PuglEventButton, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref72cc0df2 != nil {
		return x.ref72cc0df2, nil
	}
	mem72cc0df2 := allocEventButtonMemory(1)
	ref72cc0df2 := (*C.PuglEventButton)(mem72cc0df2)
	allocs72cc0df2 := new(cgoAllocMap)
	allocs72cc0df2.Add(mem72cc0df2)

	var c_type_allocs *cgoAllocMap
	ref72cc0df2._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs72cc0df2.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref72cc0df2.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref72cc0df2.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cflags_allocs)

	var ctime_allocs *cgoAllocMap
	ref72cc0df2.time, ctime_allocs = (C.uint32_t)(x.Time), cgoAllocsUnknown
	allocs72cc0df2.Borrow(ctime_allocs)

	var cx_allocs *cgoAllocMap
	ref72cc0df2.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref72cc0df2.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cy_allocs)

	var cx_root_allocs *cgoAllocMap
	ref72cc0df2.x_root, cx_root_allocs = (C.double)(x.XRoot), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cx_root_allocs)

	var cy_root_allocs *cgoAllocMap
	ref72cc0df2.y_root, cy_root_allocs = (C.double)(x.YRoot), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cy_root_allocs)

	var cstate_allocs *cgoAllocMap
	ref72cc0df2.state, cstate_allocs = (C.uint)(x.State), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cstate_allocs)

	var cbutton_allocs *cgoAllocMap
	ref72cc0df2.button, cbutton_allocs = (C.uint)(x.Button), cgoAllocsUnknown
	allocs72cc0df2.Borrow(cbutton_allocs)

	x.ref72cc0df2 = ref72cc0df2
	x.allocs72cc0df2 = allocs72cc0df2
	return ref72cc0df2, allocs72cc0df2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventButton) PassValue() (C.PuglEventButton, *cgoAllocMap) {
	if x.ref72cc0df2 != nil {
		return *x.ref72cc0df2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventButton) Deref() {
	if x.ref72cc0df2 == nil {
		return
	}
	x.Type = (EventType)(x.ref72cc0df2._type)
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxf95e7c8.Data = uintptr(unsafe.Pointer(x.ref72cc0df2.view))
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.Flags = (uint32)(x.ref72cc0df2.flags)
	x.Time = (uint32)(x.ref72cc0df2.time)
	x.X = (float64)(x.ref72cc0df2.x)
	x.Y = (float64)(x.ref72cc0df2.y)
	x.XRoot = (float64)(x.ref72cc0df2.x_root)
	x.YRoot = (float64)(x.ref72cc0df2.y_root)
	x.State = (uint32)(x.ref72cc0df2.state)
	x.Button = (uint32)(x.ref72cc0df2.button)
}

// allocEventConfigureMemory allocates memory for type C.PuglEventConfigure in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventConfigureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventConfigureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventConfigureValue = unsafe.Sizeof([1]C.PuglEventConfigure{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventConfigure) Ref() *C.PuglEventConfigure {
	if x == nil {
		return nil
	}
	return x.ref996e498a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventConfigure) Free() {
	if x != nil && x.allocs996e498a != nil {
		x.allocs996e498a.(*cgoAllocMap).Free()
		x.ref996e498a = nil
	}
}

// NewEventConfigureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventConfigureRef(ref unsafe.Pointer) *EventConfigure {
	if ref == nil {
		return nil
	}
	obj := new(EventConfigure)
	obj.ref996e498a = (*C.PuglEventConfigure)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventConfigure) PassRef() (*C.PuglEventConfigure, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref996e498a != nil {
		return x.ref996e498a, nil
	}
	mem996e498a := allocEventConfigureMemory(1)
	ref996e498a := (*C.PuglEventConfigure)(mem996e498a)
	allocs996e498a := new(cgoAllocMap)
	allocs996e498a.Add(mem996e498a)

	var c_type_allocs *cgoAllocMap
	ref996e498a._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs996e498a.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref996e498a.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs996e498a.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref996e498a.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs996e498a.Borrow(cflags_allocs)

	var cx_allocs *cgoAllocMap
	ref996e498a.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs996e498a.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref996e498a.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs996e498a.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref996e498a.width, cwidth_allocs = (C.double)(x.Width), cgoAllocsUnknown
	allocs996e498a.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref996e498a.height, cheight_allocs = (C.double)(x.Height), cgoAllocsUnknown
	allocs996e498a.Borrow(cheight_allocs)

	x.ref996e498a = ref996e498a
	x.allocs996e498a = allocs996e498a
	return ref996e498a, allocs996e498a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventConfigure) PassValue() (C.PuglEventConfigure, *cgoAllocMap) {
	if x.ref996e498a != nil {
		return *x.ref996e498a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventConfigure) Deref() {
	if x.ref996e498a == nil {
		return
	}
	x.Type = (EventType)(x.ref996e498a._type)
	hxff2234b := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxff2234b.Data = uintptr(unsafe.Pointer(x.ref996e498a.view))
	hxff2234b.Cap = 0x7fffffff
	// hxff2234b.Len = ?

	x.Flags = (uint32)(x.ref996e498a.flags)
	x.X = (float64)(x.ref996e498a.x)
	x.Y = (float64)(x.ref996e498a.y)
	x.Width = (float64)(x.ref996e498a.width)
	x.Height = (float64)(x.ref996e498a.height)
}

// allocEventExposeMemory allocates memory for type C.PuglEventExpose in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventExposeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventExposeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventExposeValue = unsafe.Sizeof([1]C.PuglEventExpose{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventExpose) Ref() *C.PuglEventExpose {
	if x == nil {
		return nil
	}
	return x.ref79eda6e8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventExpose) Free() {
	if x != nil && x.allocs79eda6e8 != nil {
		x.allocs79eda6e8.(*cgoAllocMap).Free()
		x.ref79eda6e8 = nil
	}
}

// NewEventExposeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventExposeRef(ref unsafe.Pointer) *EventExpose {
	if ref == nil {
		return nil
	}
	obj := new(EventExpose)
	obj.ref79eda6e8 = (*C.PuglEventExpose)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventExpose) PassRef() (*C.PuglEventExpose, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref79eda6e8 != nil {
		return x.ref79eda6e8, nil
	}
	mem79eda6e8 := allocEventExposeMemory(1)
	ref79eda6e8 := (*C.PuglEventExpose)(mem79eda6e8)
	allocs79eda6e8 := new(cgoAllocMap)
	allocs79eda6e8.Add(mem79eda6e8)

	var c_type_allocs *cgoAllocMap
	ref79eda6e8._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs79eda6e8.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref79eda6e8.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref79eda6e8.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cflags_allocs)

	var cx_allocs *cgoAllocMap
	ref79eda6e8.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref79eda6e8.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cy_allocs)

	var cwidth_allocs *cgoAllocMap
	ref79eda6e8.width, cwidth_allocs = (C.double)(x.Width), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cwidth_allocs)

	var cheight_allocs *cgoAllocMap
	ref79eda6e8.height, cheight_allocs = (C.double)(x.Height), cgoAllocsUnknown
	allocs79eda6e8.Borrow(cheight_allocs)

	var ccount_allocs *cgoAllocMap
	ref79eda6e8.count, ccount_allocs = (C.int)(x.Count), cgoAllocsUnknown
	allocs79eda6e8.Borrow(ccount_allocs)

	x.ref79eda6e8 = ref79eda6e8
	x.allocs79eda6e8 = allocs79eda6e8
	return ref79eda6e8, allocs79eda6e8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventExpose) PassValue() (C.PuglEventExpose, *cgoAllocMap) {
	if x.ref79eda6e8 != nil {
		return *x.ref79eda6e8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventExpose) Deref() {
	if x.ref79eda6e8 == nil {
		return
	}
	x.Type = (EventType)(x.ref79eda6e8._type)
	hxff73280 := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxff73280.Data = uintptr(unsafe.Pointer(x.ref79eda6e8.view))
	hxff73280.Cap = 0x7fffffff
	// hxff73280.Len = ?

	x.Flags = (uint32)(x.ref79eda6e8.flags)
	x.X = (float64)(x.ref79eda6e8.x)
	x.Y = (float64)(x.ref79eda6e8.y)
	x.Width = (float64)(x.ref79eda6e8.width)
	x.Height = (float64)(x.ref79eda6e8.height)
	x.Count = (int32)(x.ref79eda6e8.count)
}

// allocEventCloseMemory allocates memory for type C.PuglEventClose in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCloseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCloseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCloseValue = unsafe.Sizeof([1]C.PuglEventClose{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventClose) Ref() *C.PuglEventClose {
	if x == nil {
		return nil
	}
	return x.ref6b960563
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventClose) Free() {
	if x != nil && x.allocs6b960563 != nil {
		x.allocs6b960563.(*cgoAllocMap).Free()
		x.ref6b960563 = nil
	}
}

// NewEventCloseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventCloseRef(ref unsafe.Pointer) *EventClose {
	if ref == nil {
		return nil
	}
	obj := new(EventClose)
	obj.ref6b960563 = (*C.PuglEventClose)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventClose) PassRef() (*C.PuglEventClose, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6b960563 != nil {
		return x.ref6b960563, nil
	}
	mem6b960563 := allocEventCloseMemory(1)
	ref6b960563 := (*C.PuglEventClose)(mem6b960563)
	allocs6b960563 := new(cgoAllocMap)
	allocs6b960563.Add(mem6b960563)

	var c_type_allocs *cgoAllocMap
	ref6b960563._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs6b960563.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref6b960563.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs6b960563.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref6b960563.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs6b960563.Borrow(cflags_allocs)

	x.ref6b960563 = ref6b960563
	x.allocs6b960563 = allocs6b960563
	return ref6b960563, allocs6b960563

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventClose) PassValue() (C.PuglEventClose, *cgoAllocMap) {
	if x.ref6b960563 != nil {
		return *x.ref6b960563, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventClose) Deref() {
	if x.ref6b960563 == nil {
		return
	}
	x.Type = (EventType)(x.ref6b960563._type)
	hxfa9955c := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxfa9955c.Data = uintptr(unsafe.Pointer(x.ref6b960563.view))
	hxfa9955c.Cap = 0x7fffffff
	// hxfa9955c.Len = ?

	x.Flags = (uint32)(x.ref6b960563.flags)
}

// allocEventKeyMemory allocates memory for type C.PuglEventKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventKeyValue = unsafe.Sizeof([1]C.PuglEventKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventKey) Ref() *C.PuglEventKey {
	if x == nil {
		return nil
	}
	return x.ref788872a6
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventKey) Free() {
	if x != nil && x.allocs788872a6 != nil {
		x.allocs788872a6.(*cgoAllocMap).Free()
		x.ref788872a6 = nil
	}
}

// NewEventKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventKeyRef(ref unsafe.Pointer) *EventKey {
	if ref == nil {
		return nil
	}
	obj := new(EventKey)
	obj.ref788872a6 = (*C.PuglEventKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventKey) PassRef() (*C.PuglEventKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref788872a6 != nil {
		return x.ref788872a6, nil
	}
	mem788872a6 := allocEventKeyMemory(1)
	ref788872a6 := (*C.PuglEventKey)(mem788872a6)
	allocs788872a6 := new(cgoAllocMap)
	allocs788872a6.Add(mem788872a6)

	var c_type_allocs *cgoAllocMap
	ref788872a6._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs788872a6.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref788872a6.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs788872a6.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref788872a6.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs788872a6.Borrow(cflags_allocs)

	var ctime_allocs *cgoAllocMap
	ref788872a6.time, ctime_allocs = (C.uint32_t)(x.Time), cgoAllocsUnknown
	allocs788872a6.Borrow(ctime_allocs)

	var cx_allocs *cgoAllocMap
	ref788872a6.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocs788872a6.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref788872a6.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocs788872a6.Borrow(cy_allocs)

	var cx_root_allocs *cgoAllocMap
	ref788872a6.x_root, cx_root_allocs = (C.double)(x.XRoot), cgoAllocsUnknown
	allocs788872a6.Borrow(cx_root_allocs)

	var cy_root_allocs *cgoAllocMap
	ref788872a6.y_root, cy_root_allocs = (C.double)(x.YRoot), cgoAllocsUnknown
	allocs788872a6.Borrow(cy_root_allocs)

	var cstate_allocs *cgoAllocMap
	ref788872a6.state, cstate_allocs = (C.uint)(x.State), cgoAllocsUnknown
	allocs788872a6.Borrow(cstate_allocs)

	var ckeycode_allocs *cgoAllocMap
	ref788872a6.keycode, ckeycode_allocs = (C.uint)(x.Keycode), cgoAllocsUnknown
	allocs788872a6.Borrow(ckeycode_allocs)

	var ccharacter_allocs *cgoAllocMap
	ref788872a6.character, ccharacter_allocs = (C.uint32_t)(x.Character), cgoAllocsUnknown
	allocs788872a6.Borrow(ccharacter_allocs)

	var cspecial_allocs *cgoAllocMap
	ref788872a6.special, cspecial_allocs = (C.PuglKey)(x.Special), cgoAllocsUnknown
	allocs788872a6.Borrow(cspecial_allocs)

	var cutf8_allocs *cgoAllocMap
	ref788872a6.utf8, cutf8_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.Utf8)), cgoAllocsUnknown
	allocs788872a6.Borrow(cutf8_allocs)

	var cfilter_allocs *cgoAllocMap
	ref788872a6.filter, cfilter_allocs = (C.bool)(x.Filter), cgoAllocsUnknown
	allocs788872a6.Borrow(cfilter_allocs)

	x.ref788872a6 = ref788872a6
	x.allocs788872a6 = allocs788872a6
	return ref788872a6, allocs788872a6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventKey) PassValue() (C.PuglEventKey, *cgoAllocMap) {
	if x.ref788872a6 != nil {
		return *x.ref788872a6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventKey) Deref() {
	if x.ref788872a6 == nil {
		return
	}
	x.Type = (EventType)(x.ref788872a6._type)
	hxfa3f05c := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxfa3f05c.Data = uintptr(unsafe.Pointer(x.ref788872a6.view))
	hxfa3f05c.Cap = 0x7fffffff
	// hxfa3f05c.Len = ?

	x.Flags = (uint32)(x.ref788872a6.flags)
	x.Time = (uint32)(x.ref788872a6.time)
	x.X = (float64)(x.ref788872a6.x)
	x.Y = (float64)(x.ref788872a6.y)
	x.XRoot = (float64)(x.ref788872a6.x_root)
	x.YRoot = (float64)(x.ref788872a6.y_root)
	x.State = (uint32)(x.ref788872a6.state)
	x.Keycode = (uint32)(x.ref788872a6.keycode)
	x.Character = (uint32)(x.ref788872a6.character)
	x.Special = (Key)(x.ref788872a6.special)
	x.Utf8 = *(*[8]byte)(unsafe.Pointer(&x.ref788872a6.utf8))
	x.Filter = (int32)(x.ref788872a6.filter)
}

// allocEventCrossingMemory allocates memory for type C.PuglEventCrossing in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventCrossingMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventCrossingValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventCrossingValue = unsafe.Sizeof([1]C.PuglEventCrossing{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventCrossing) Ref() *C.PuglEventCrossing {
	if x == nil {
		return nil
	}
	return x.reffcf6c399
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventCrossing) Free() {
	if x != nil && x.allocsfcf6c399 != nil {
		x.allocsfcf6c399.(*cgoAllocMap).Free()
		x.reffcf6c399 = nil
	}
}

// NewEventCrossingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventCrossingRef(ref unsafe.Pointer) *EventCrossing {
	if ref == nil {
		return nil
	}
	obj := new(EventCrossing)
	obj.reffcf6c399 = (*C.PuglEventCrossing)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventCrossing) PassRef() (*C.PuglEventCrossing, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffcf6c399 != nil {
		return x.reffcf6c399, nil
	}
	memfcf6c399 := allocEventCrossingMemory(1)
	reffcf6c399 := (*C.PuglEventCrossing)(memfcf6c399)
	allocsfcf6c399 := new(cgoAllocMap)
	allocsfcf6c399.Add(memfcf6c399)

	var c_type_allocs *cgoAllocMap
	reffcf6c399._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocsfcf6c399.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	reffcf6c399.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	reffcf6c399.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cflags_allocs)

	var ctime_allocs *cgoAllocMap
	reffcf6c399.time, ctime_allocs = (C.uint32_t)(x.Time), cgoAllocsUnknown
	allocsfcf6c399.Borrow(ctime_allocs)

	var cx_allocs *cgoAllocMap
	reffcf6c399.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	reffcf6c399.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cy_allocs)

	var cx_root_allocs *cgoAllocMap
	reffcf6c399.x_root, cx_root_allocs = (C.double)(x.XRoot), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cx_root_allocs)

	var cy_root_allocs *cgoAllocMap
	reffcf6c399.y_root, cy_root_allocs = (C.double)(x.YRoot), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cy_root_allocs)

	var cstate_allocs *cgoAllocMap
	reffcf6c399.state, cstate_allocs = (C.uint)(x.State), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cstate_allocs)

	var cmode_allocs *cgoAllocMap
	reffcf6c399.mode, cmode_allocs = (C.PuglCrossingMode)(x.Mode), cgoAllocsUnknown
	allocsfcf6c399.Borrow(cmode_allocs)

	x.reffcf6c399 = reffcf6c399
	x.allocsfcf6c399 = allocsfcf6c399
	return reffcf6c399, allocsfcf6c399

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventCrossing) PassValue() (C.PuglEventCrossing, *cgoAllocMap) {
	if x.reffcf6c399 != nil {
		return *x.reffcf6c399, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventCrossing) Deref() {
	if x.reffcf6c399 == nil {
		return
	}
	x.Type = (EventType)(x.reffcf6c399._type)
	hxf0d18b7 := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxf0d18b7.Data = uintptr(unsafe.Pointer(x.reffcf6c399.view))
	hxf0d18b7.Cap = 0x7fffffff
	// hxf0d18b7.Len = ?

	x.Flags = (uint32)(x.reffcf6c399.flags)
	x.Time = (uint32)(x.reffcf6c399.time)
	x.X = (float64)(x.reffcf6c399.x)
	x.Y = (float64)(x.reffcf6c399.y)
	x.XRoot = (float64)(x.reffcf6c399.x_root)
	x.YRoot = (float64)(x.reffcf6c399.y_root)
	x.State = (uint32)(x.reffcf6c399.state)
	x.Mode = (CrossingMode)(x.reffcf6c399.mode)
}

// allocEventMotionMemory allocates memory for type C.PuglEventMotion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventMotionMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventMotionValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventMotionValue = unsafe.Sizeof([1]C.PuglEventMotion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventMotion) Ref() *C.PuglEventMotion {
	if x == nil {
		return nil
	}
	return x.refbd340027
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventMotion) Free() {
	if x != nil && x.allocsbd340027 != nil {
		x.allocsbd340027.(*cgoAllocMap).Free()
		x.refbd340027 = nil
	}
}

// NewEventMotionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventMotionRef(ref unsafe.Pointer) *EventMotion {
	if ref == nil {
		return nil
	}
	obj := new(EventMotion)
	obj.refbd340027 = (*C.PuglEventMotion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventMotion) PassRef() (*C.PuglEventMotion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbd340027 != nil {
		return x.refbd340027, nil
	}
	membd340027 := allocEventMotionMemory(1)
	refbd340027 := (*C.PuglEventMotion)(membd340027)
	allocsbd340027 := new(cgoAllocMap)
	allocsbd340027.Add(membd340027)

	var c_type_allocs *cgoAllocMap
	refbd340027._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocsbd340027.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	refbd340027.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocsbd340027.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	refbd340027.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocsbd340027.Borrow(cflags_allocs)

	var ctime_allocs *cgoAllocMap
	refbd340027.time, ctime_allocs = (C.uint32_t)(x.Time), cgoAllocsUnknown
	allocsbd340027.Borrow(ctime_allocs)

	var cx_allocs *cgoAllocMap
	refbd340027.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocsbd340027.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refbd340027.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocsbd340027.Borrow(cy_allocs)

	var cx_root_allocs *cgoAllocMap
	refbd340027.x_root, cx_root_allocs = (C.double)(x.XRoot), cgoAllocsUnknown
	allocsbd340027.Borrow(cx_root_allocs)

	var cy_root_allocs *cgoAllocMap
	refbd340027.y_root, cy_root_allocs = (C.double)(x.YRoot), cgoAllocsUnknown
	allocsbd340027.Borrow(cy_root_allocs)

	var cstate_allocs *cgoAllocMap
	refbd340027.state, cstate_allocs = (C.uint)(x.State), cgoAllocsUnknown
	allocsbd340027.Borrow(cstate_allocs)

	var cis_hint_allocs *cgoAllocMap
	refbd340027.is_hint, cis_hint_allocs = (C.bool)(x.IsHint), cgoAllocsUnknown
	allocsbd340027.Borrow(cis_hint_allocs)

	var cfocus_allocs *cgoAllocMap
	refbd340027.focus, cfocus_allocs = (C.bool)(x.Focus), cgoAllocsUnknown
	allocsbd340027.Borrow(cfocus_allocs)

	x.refbd340027 = refbd340027
	x.allocsbd340027 = allocsbd340027
	return refbd340027, allocsbd340027

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventMotion) PassValue() (C.PuglEventMotion, *cgoAllocMap) {
	if x.refbd340027 != nil {
		return *x.refbd340027, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventMotion) Deref() {
	if x.refbd340027 == nil {
		return
	}
	x.Type = (EventType)(x.refbd340027._type)
	hxf2fab0d := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxf2fab0d.Data = uintptr(unsafe.Pointer(x.refbd340027.view))
	hxf2fab0d.Cap = 0x7fffffff
	// hxf2fab0d.Len = ?

	x.Flags = (uint32)(x.refbd340027.flags)
	x.Time = (uint32)(x.refbd340027.time)
	x.X = (float64)(x.refbd340027.x)
	x.Y = (float64)(x.refbd340027.y)
	x.XRoot = (float64)(x.refbd340027.x_root)
	x.YRoot = (float64)(x.refbd340027.y_root)
	x.State = (uint32)(x.refbd340027.state)
	x.IsHint = (int32)(x.refbd340027.is_hint)
	x.Focus = (int32)(x.refbd340027.focus)
}

// allocEventScrollMemory allocates memory for type C.PuglEventScroll in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventScrollMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventScrollValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventScrollValue = unsafe.Sizeof([1]C.PuglEventScroll{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventScroll) Ref() *C.PuglEventScroll {
	if x == nil {
		return nil
	}
	return x.refa5dd9f4c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventScroll) Free() {
	if x != nil && x.allocsa5dd9f4c != nil {
		x.allocsa5dd9f4c.(*cgoAllocMap).Free()
		x.refa5dd9f4c = nil
	}
}

// NewEventScrollRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventScrollRef(ref unsafe.Pointer) *EventScroll {
	if ref == nil {
		return nil
	}
	obj := new(EventScroll)
	obj.refa5dd9f4c = (*C.PuglEventScroll)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventScroll) PassRef() (*C.PuglEventScroll, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5dd9f4c != nil {
		return x.refa5dd9f4c, nil
	}
	mema5dd9f4c := allocEventScrollMemory(1)
	refa5dd9f4c := (*C.PuglEventScroll)(mema5dd9f4c)
	allocsa5dd9f4c := new(cgoAllocMap)
	allocsa5dd9f4c.Add(mema5dd9f4c)

	var c_type_allocs *cgoAllocMap
	refa5dd9f4c._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	refa5dd9f4c.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	refa5dd9f4c.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cflags_allocs)

	var ctime_allocs *cgoAllocMap
	refa5dd9f4c.time, ctime_allocs = (C.uint32_t)(x.Time), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(ctime_allocs)

	var cx_allocs *cgoAllocMap
	refa5dd9f4c.x, cx_allocs = (C.double)(x.X), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	refa5dd9f4c.y, cy_allocs = (C.double)(x.Y), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cy_allocs)

	var cx_root_allocs *cgoAllocMap
	refa5dd9f4c.x_root, cx_root_allocs = (C.double)(x.XRoot), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cx_root_allocs)

	var cy_root_allocs *cgoAllocMap
	refa5dd9f4c.y_root, cy_root_allocs = (C.double)(x.YRoot), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cy_root_allocs)

	var cstate_allocs *cgoAllocMap
	refa5dd9f4c.state, cstate_allocs = (C.uint)(x.State), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cstate_allocs)

	var cdx_allocs *cgoAllocMap
	refa5dd9f4c.dx, cdx_allocs = (C.double)(x.Dx), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cdx_allocs)

	var cdy_allocs *cgoAllocMap
	refa5dd9f4c.dy, cdy_allocs = (C.double)(x.Dy), cgoAllocsUnknown
	allocsa5dd9f4c.Borrow(cdy_allocs)

	x.refa5dd9f4c = refa5dd9f4c
	x.allocsa5dd9f4c = allocsa5dd9f4c
	return refa5dd9f4c, allocsa5dd9f4c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventScroll) PassValue() (C.PuglEventScroll, *cgoAllocMap) {
	if x.refa5dd9f4c != nil {
		return *x.refa5dd9f4c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventScroll) Deref() {
	if x.refa5dd9f4c == nil {
		return
	}
	x.Type = (EventType)(x.refa5dd9f4c._type)
	hxf69fe70 := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxf69fe70.Data = uintptr(unsafe.Pointer(x.refa5dd9f4c.view))
	hxf69fe70.Cap = 0x7fffffff
	// hxf69fe70.Len = ?

	x.Flags = (uint32)(x.refa5dd9f4c.flags)
	x.Time = (uint32)(x.refa5dd9f4c.time)
	x.X = (float64)(x.refa5dd9f4c.x)
	x.Y = (float64)(x.refa5dd9f4c.y)
	x.XRoot = (float64)(x.refa5dd9f4c.x_root)
	x.YRoot = (float64)(x.refa5dd9f4c.y_root)
	x.State = (uint32)(x.refa5dd9f4c.state)
	x.Dx = (float64)(x.refa5dd9f4c.dx)
	x.Dy = (float64)(x.refa5dd9f4c.dy)
}

// allocEventFocusMemory allocates memory for type C.PuglEventFocus in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEventFocusMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfEventFocusValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfEventFocusValue = unsafe.Sizeof([1]C.PuglEventFocus{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EventFocus) Ref() *C.PuglEventFocus {
	if x == nil {
		return nil
	}
	return x.ref1a57ce4e
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EventFocus) Free() {
	if x != nil && x.allocs1a57ce4e != nil {
		x.allocs1a57ce4e.(*cgoAllocMap).Free()
		x.ref1a57ce4e = nil
	}
}

// NewEventFocusRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEventFocusRef(ref unsafe.Pointer) *EventFocus {
	if ref == nil {
		return nil
	}
	obj := new(EventFocus)
	obj.ref1a57ce4e = (*C.PuglEventFocus)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EventFocus) PassRef() (*C.PuglEventFocus, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a57ce4e != nil {
		return x.ref1a57ce4e, nil
	}
	mem1a57ce4e := allocEventFocusMemory(1)
	ref1a57ce4e := (*C.PuglEventFocus)(mem1a57ce4e)
	allocs1a57ce4e := new(cgoAllocMap)
	allocs1a57ce4e.Add(mem1a57ce4e)

	var c_type_allocs *cgoAllocMap
	ref1a57ce4e._type, c_type_allocs = (C.PuglEventType)(x.Type), cgoAllocsUnknown
	allocs1a57ce4e.Borrow(c_type_allocs)

	var cview_allocs *cgoAllocMap
	ref1a57ce4e.view, cview_allocs = (*C.PuglView)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.View)).Data)), cgoAllocsUnknown
	allocs1a57ce4e.Borrow(cview_allocs)

	var cflags_allocs *cgoAllocMap
	ref1a57ce4e.flags, cflags_allocs = (C.uint32_t)(x.Flags), cgoAllocsUnknown
	allocs1a57ce4e.Borrow(cflags_allocs)

	var cgrab_allocs *cgoAllocMap
	ref1a57ce4e.grab, cgrab_allocs = (C.bool)(x.Grab), cgoAllocsUnknown
	allocs1a57ce4e.Borrow(cgrab_allocs)

	x.ref1a57ce4e = ref1a57ce4e
	x.allocs1a57ce4e = allocs1a57ce4e
	return ref1a57ce4e, allocs1a57ce4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EventFocus) PassValue() (C.PuglEventFocus, *cgoAllocMap) {
	if x.ref1a57ce4e != nil {
		return *x.ref1a57ce4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EventFocus) Deref() {
	if x.ref1a57ce4e == nil {
		return
	}
	x.Type = (EventType)(x.ref1a57ce4e._type)
	hxf65bf54 := (*sliceHeader)(unsafe.Pointer(&x.View))
	hxf65bf54.Data = uintptr(unsafe.Pointer(x.ref1a57ce4e.view))
	hxf65bf54.Cap = 0x7fffffff
	// hxf65bf54.Len = ?

	x.Flags = (uint32)(x.ref1a57ce4e.flags)
	x.Grab = (int32)(x.ref1a57ce4e.grab)
}

func (x EventFunc) PassRef() (ref *C.PuglEventFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if eventFuncD2BBAEFBFunc == nil {
		eventFuncD2BBAEFBFunc = x
	}
	return (*C.PuglEventFunc)(C.PuglEventFunc_d2bbaefb), nil
}

func (x EventFunc) PassValue() (ref C.PuglEventFunc, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	if eventFuncD2BBAEFBFunc == nil {
		eventFuncD2BBAEFBFunc = x
	}
	return (C.PuglEventFunc)(C.PuglEventFunc_d2bbaefb), nil
}

func NewEventFuncRef(ref unsafe.Pointer) *EventFunc {
	return (*EventFunc)(ref)
}

//export eventFuncD2BBAEFB
func eventFuncD2BBAEFB(cview *C.PuglView, cevent *C.PuglEvent) {
	if eventFuncD2BBAEFBFunc != nil {
		viewd2bbaefb := (*View)(unsafe.Pointer(cview))
		eventd2bbaefb := (*Event)(unsafe.Pointer(cevent))
		eventFuncD2BBAEFBFunc(viewd2bbaefb, eventd2bbaefb)
		return
	}
	panic("callback func has not been set (race?)")
}

var eventFuncD2BBAEFBFunc EventFunc

// allocCairoGLMemory allocates memory for type C.PuglCairoGL in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCairoGLMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCairoGLValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCairoGLValue = unsafe.Sizeof([1]C.PuglCairoGL{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CairoGL) Ref() *C.PuglCairoGL {
	if x == nil {
		return nil
	}
	return x.refdc99edd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CairoGL) Free() {
	if x != nil && x.allocsdc99edd9 != nil {
		x.allocsdc99edd9.(*cgoAllocMap).Free()
		x.refdc99edd9 = nil
	}
}

// NewCairoGLRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCairoGLRef(ref unsafe.Pointer) *CairoGL {
	if ref == nil {
		return nil
	}
	obj := new(CairoGL)
	obj.refdc99edd9 = (*C.PuglCairoGL)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CairoGL) PassRef() (*C.PuglCairoGL, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdc99edd9 != nil {
		return x.refdc99edd9, nil
	}
	memdc99edd9 := allocCairoGLMemory(1)
	refdc99edd9 := (*C.PuglCairoGL)(memdc99edd9)
	allocsdc99edd9 := new(cgoAllocMap)
	allocsdc99edd9.Add(memdc99edd9)

	var ctexture_id_allocs *cgoAllocMap
	refdc99edd9.texture_id, ctexture_id_allocs = (C.uint)(x.TextureId), cgoAllocsUnknown
	allocsdc99edd9.Borrow(ctexture_id_allocs)

	var cbuffer_allocs *cgoAllocMap
	refdc99edd9.buffer, cbuffer_allocs = (*C.uint8_t)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Buffer)).Data)), cgoAllocsUnknown
	allocsdc99edd9.Borrow(cbuffer_allocs)

	x.refdc99edd9 = refdc99edd9
	x.allocsdc99edd9 = allocsdc99edd9
	return refdc99edd9, allocsdc99edd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CairoGL) PassValue() (C.PuglCairoGL, *cgoAllocMap) {
	if x.refdc99edd9 != nil {
		return *x.refdc99edd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CairoGL) Deref() {
	if x.refdc99edd9 == nil {
		return
	}
	x.TextureId = (uint32)(x.refdc99edd9.texture_id)
	hxf3b8dbd := (*sliceHeader)(unsafe.Pointer(&x.Buffer))
	hxf3b8dbd.Data = uintptr(unsafe.Pointer(x.refdc99edd9.buffer))
	hxf3b8dbd.Cap = 0x7fffffff
	// hxf3b8dbd.Len = ?

}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(unsafe.Pointer(h.Data)), cgoAllocsUnknown
}

type stringHeader struct {
	Data uintptr
	Len  int
}
